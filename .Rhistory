x = die
,size = 2
,replace = TRUE
,prob = c(1/8, 1/8, 1/8, 1/8, 1/8, 3/8))
sum(dice)
}
roll_weighted <- function() {
die  <- 1:6
dice <- sample(
x = die
,size = 2
,replace = TRUE
,prob = c(1/8, 1/8, 1/8, 1/8, 1/8, 3/8))
sum(dice)
}
rolls <- replicate(n = 10000, roll_weighted())
ggplot2::qplot(x = rolls, binwidth = 1)
# atomic vectors - simple vectors
die <- c(1, 2, 3, 4, 5, 6)
die
is.vector(die)
five <- 5
five
is.vector(five)
length(five)
length(die)
# there are six basic types of atomic vectors
# doubles, integers, characters, logicals, complex, and raw
int <- 1L
int
tect <- "ace"
text <- "ace"
text
int <- c(1L, 5L)
int
text <- c("ace", "hearts")
text
sum(die)
sum(text)
sum(int)
# Doubles - double vector stores regular numbers
die <- c(1, 2, 3, 4, 5, 6)
typeof(die)
# Integers - numbers that can be written without a decimal component
int <- c(-1L, 2L, 4L)
int
typeof(int)
# 3 # Character - stores small pieces of text
text <- c("Hello", "World")
text
typeof(text)
typeof("Hello")
# 4 # Logicals - Logical vectors store TRUEs and FALSEs, R’s form of Boolean data. Logicals are very
# helpful for doing things like comparisons
3 > 4
logic <- c(TRUE, FALSE, TRUE)
typof(logic)
logic <- c(TRUE, FALSE, TRUE)
typof(logic)
typeof(logic)
typeof(F)
# 5 # Complex - store complex numbers.
# To create a complex vector, add an imaginary term to a number with i:
comp <- c(1, 1i, 2, 2i, 3, 3i)
comp
# 5 # Complex - store complex numbers.
# To create a complex vector, add an imaginary term to a number with i:
comp <- c(1 + 1i, 1 + 2i, 1 + 3i)
comp
typeof(comp)
# 6 # Raw - store raw bytes of data
raw(3)
typeof(raw)
typeof(raw(3))
# Exercise
hand <- c("ace", "king", "queen", "jack", "ten")
hand
typeof(hand)
# Attributes - like "metadata" attached to vectors and objects
attributes(die)
names(die)
names(die) <- c("one", "two", "three", "four", "five", "six")
names(die)
attributes(die)
die
die + 1
names(die) <- c("uno", "dos", "tres", "quatro", "cinco", "seis")
die
names(die) <-  NULL # remove names
die
# Dim - transform an atomic vector into an n-dimensional array e.g. 2X3
dim(die) <- c(2,3)
die
# or 3X2
dim(die) <- c(3,2)
die
# or a 1 × 2 × 3 hypercube
dim(die) <- c(1, 2, 3)
die
# see matrix or array functions that perform like dim but with more options
# Matrices - store values in a two-dimensional array
m <- matrix(die, nrow = 2)
m
m <- matrix(die, nrow = 2, byrow = TRUE)
m
# More info
?matrix
# Arrays - creates an n-dimensional array
# provide an atomic vector as the first argument, and a vector
# of dimensions as the second argument
ar <- array(c(11:14, 21:24, 31:34), dim = c(2, 2, 3))
ar
# Exercise "
hand1 <- c("ace",    "king",   "queen",  "jack",   "ten",
"spades", "spades", "spades", "spades", "spades")
hand1
# 3 ways to do the samething
matrix(hand1, nrow = 2)
# 3 ways to do the samething
matrix(hand1, nrow = 5)
matrix(hand1, ncol = 2)
dim(hand1) <- c(5, 2)
hand1
(dim(hand1) <- c(5, 2))
hand1
hand2 <- c("ace",    "spades", "king",   "spades", "queen",
"spades", "jack",   "spades", "ten",    "spades")
matrix(hand1, nrow = 5, byrow = TRUE)
matrix(hand2, nrow = 5, byrow = TRUE)
matrix(hand2, ncol = 2, byrow = TRUE)
# Class - changing the dimensions of your object will change the object’s class attribute
dim(die) <- c(2, 3)
typeof(die)
class(die)
attributes(die)
class("Hello")
class(5)
# Dates and Times
now <- Sys.time()
now
typeof(now)
class(now)
unclass(now)
mil <- 1000000
mil
class(mil) <- c("POSIXct", "POSIXt")
mil
# Factors - is a class and R’s way of storing categorical information
gender <- factor(c("male", "female", "female", "male"))
gender
typeof(gender)
attributes(gender)
unclass(gender)
attr(, levels())
attr(,"levels")
unclass(gender) # how R stores the information
gender
as.character(gender)
# Exercise
card <- c("ace", "hearts" 1)
card
# Exercise
card <- c("ace", "hearts", 1)
card
# Coercion - R always uses the same rules to coerce data to a single type. If character
#strings are present, everything will be coerced to a character string. Otherwise, logicals
#are coerced to numerics.
sum(c(TRUE, TRUE, FALSE, FALSE))
sum(c(1, 1, 0, 0))
as.character(1)
as.logical(1)
as.numeric(FALSE)
# Lists - lists group together R objects, such as atomic vectors and other lists
list1 <- list(100:130, "R", list(TRUE, FALSE))
# Exercise
card <- list("ace", "hearts", 1)
card
# Dataframes - group vectors together into a two-dimensional table. Each vector becomes a column in the table.
df <- data.frame(face   = c("ace", "two", "six")
,suit  = c("clubs", "clubs", "clubs")
,value = c(1, 2, 3)
)
df
# NOTE: You can also give names to a list or vector when you create one of these objects.
list(face = "ace", suit = "hearts", value = 1)
c(face = "ace", suit = "hearts", value = "one")
# NOTE: You can also give names to a list or vector when you create one of these objects.
ls1 <- list(face = "ace", suit = "hearts", value = 1)
c1 <- c(face = "ace", suit = "hearts", value = "one")
attributes(ls1)
attributes(c1)
typeof(df)
class(df)
str(df)
df <- data.frame(face   = c("ace", "two", "six")
,suit  = c("clubs", "clubs", "clubs")
,value = c(1, 2, 3)
,stringsAsFactors = FALSE
)
str(df)
deck <- read.csv("~/github/programming-with-R/data/deck.csv", stringsAsFactors=FALSE)
View(deck)
# Can also use the import wizard
head(deck)
head(deck, 10)
# Saving Data
write.csv(deck, file = "./data/derived-data/datacards.csv", row.names = FALSE)
# Saving Data
write.csv(deck, file = "./data/derived-data/cards.csv", row.names = FALSE)
getwd()
?write.csv
deal(deck)
library(readr)
deck <- read_csv("data/deck.csv")
View(deck)
deal(deck)
deck[1, 1]
deck[1, c(1, 2, 3)]
deck[1, 1:3]
new <- deck[1, c(1, 2, 3)]
new
# select values from vectors as well
vec <- c(6, 1, 3, 6, 10, 5)
vec[1:#]
vec[1:3]
# select values from vectors as well
vec <- c(6, 1, 3, 6, 10, 5)
vec[1:3]
deck[1:2, 1:2]
deck[1:2, 1]
# returns a data frame
deck[1:2, 1, drop = FALSE]
# negatives returns all elements except the ements in a negative index
deck[-1, 1:3]
deck[-(2:52), 1:3]
deck[-1, 1]
# blank spaces return every value in a dimension
deck[1, ]
# logical values - will return each row that corresponds to a TRUE
deck[1, c(TRUE, TRUE, FALSE)]
rows <- c(TRUE, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F,
F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F,
F, F, F, F, F, F, F, F, F, F, F, F, F, F)
deck[rows, ]
vec[c(F, T, F, T, F, T)]
# extract using names
deck[1, c("face", "suit", "value")]
deck[ , "value"]
cards[1, ]
deck[1, ]
deal(deck)
deal <- function(deck){
deck[1, ]
}
deal(deck)
deal(deck)
# shuffle cards to get a different row 1 each time
deck2 <- deck[1:52, ]
head(deck2)
deck3
deck3 <- deck[c(2, 1, 3:52), ]
deck3 <- deck[c(2, 1, 3:52), ]
head(deck3)
random <- sample(1:52, size = 52)
random
random
deck4 <- deck[random, ]
head(deck4)
random
random
random
random
random
head(deck4)
head(deck4)
random <- sample(1:52, size = 52)
random
deck4 <- deck[random, ]
head(deck4)
# Exercise
card <- deck
shuffle <- function(cards) {
random <- sample(1:52, size = 52)
cards[random, ]
}
deal(deck)
deal(deck)
deck2 <- suffle(deck)
deck2 <- shuffle(deck)
deal(deck2)
deck2 <- shuffle(deck)
deal(deck2)
# doallar signs and double brackets
deck$value
mean(deck$value)
median(deck$value)
lst <- list(numbers = c(1, 2), logical = TRUE, strings = c("a", "b", "c"))
lst
lst[1]
# returns selected values as they are, with no list structure
lst$numbers
sum(lst$numbers)
# double brackets for position if name is not specifed
lst[[1]]
# single brackets keeps the list structure
lst[1]
lst["numbers"]
lst[["numbers"]]
library(readr)
deck <- read_csv("data/deck.csv")
View(deck)
rm(list=ls(all=TRUE)) #Clear the memory of variables from previous run.
# This is not called by knitr, because it's above the first chunk.
cat("\f") # clear console when working in RStudio
library(readr)
deck <- read_csv("data/deck.csv")
View(deck)
deck2 <- deck
vec <- c(0, 0, 0, 0, 0, 0)
vec
vec[1]
vec[1] <- 1000
vec
# change multiple values at once
vec[c(1, 3, 5)] <- c(1, 1, 1)
vec
vec[4:6] <- vec[4:6] + 1
vec
# you can expand the objct to accommodate new values
# there are six values of vec, we will add a seventh
vec[7] <- 0
vec
# add new variables to a data set
# add a new column with 1 to 52
deck2$new <- 1:52
head(deck2)
# remove coloumns from a data frame using NULL
deck2$new <- NULL
head(deck2)
deck2
View(deck2)
deck2[c(13, 26, 39, 52)]
deck2[c(13, 26, 39, 52), ]
deck2[c(13, 26, 39, 52, 3)]
deck2[c(13, 26, 39, 52), 3]
deck2$value[c(13, 26, 39, 52)]
deck2$value[c(13, 26, 39, 52)] <- c(14, 14, 14, 14)
View(deck2)
deck3 <- shuffle(deck)
shuffle <- function(cards) {
random <- sample(1:52, size = 52)
cards[random, ]
}
deck3 <- shuffle(deck)
head(deck3)
1 > 2
1 > c(0, 1, 2)
c(1, 2, 3) == c(3, 2, 1)
# %in% tests whether the value(s) on the left side are in the vector on the right side
1 %in% c(3, 4, 5)
c(1, 2) %in% c(3, 4, 5)
c(1, 2, 3) %in% c(3, 4, 5)
c(1, 2, 3, 4) %in% c(3, 4, 5)
# change multiple values at once
vec[c(1, 3, 5)] <- c(1, 1, 1)
vec <- c(0, 0, 0, 0, 0, 0)
# select first value of the vector named vec
vec
vec[1]
# change the value of the first value in vec from 0 to 1000
vec[1] <- 1000
vec
# change multiple values at once
vec[c(1, 3, 5)] <- c(1, 1, 1)
vec
vec[4:6] <- vec[4:6] + 1
vec
# you can expand the objct to accommodate new values
# there are six values of vec, we will add a seventh
vec[7] <- 0
vec
# %in% tests whether the value(s) on the left side are in the vector on the right side
1 %in% c(3, 4, 5)
c(1, 2) %in% c(3, 4, 5)
c(1, 2, 3) %in% c(3, 4, 5)
c(1, 2, 3, 4) %in% c(3, 4, 5)
deck <- read_csv("data/deck.csv")
View(deck)
deck2 <- deck
rm(list=ls(all=TRUE)) #Clear the memory of variables from previous run.
cat("\f") # clear console when working in RStudio
library(readr)
deck <- read_csv("data/deck.csv")
View(deck)
deck2 <- deck
vec <- c(0, 0, 0, 0, 0, 0)
# add new variables to a data set
# add a new column with 1 to 52
deck2$new <- 1:52
# remove coloumns from a data frame using NULL
deck2$new <- NULL
head(deck2)
View(deck2)
deck2[c(13, 26, 39, 52), ]
deck2[c(13, 26, 39, 52), 3]
deck2$value[c(13, 26, 39, 52)]
deck2$value[c(13, 26, 39, 52)] <- c(14, 14, 14, 14)
deck2$value[c(13, 26, 39, 52)] <-  14
View(deck2)
shuffle <- function(cards) {
random <- sample(1:52, size = 52)
cards[random, ]
}
deck3 <- shuffle(deck)
head(deck3)
# Exercise
deck2$face
deck2$face == "ace"
# sum to count the number of TRUEs in the previous vector
sum(deck2$face == "ace")
deck3$face == "ace"
deck3$value[deck3$face == "ace"]
deck3$value[deck3$face == "ace"] <- 14
head(deck3)
shuffle(deck3)
head(deck3)
shuffle(deck3)
head(deck3)
head(deck3)
View(deck3)
# returns a logical vector
deck3$face == "ace"
# returns a logical vector
deck3$face == "ace"
deck3$value[deck3$face == "ace"]
deck4 <- deck
deck4$value <- 0
head(deck4, 13)
deck4$suit == "hearts"
# test to select the values of these cards
deck4$value[deck4$suit =="hearts"]
# assign a new number to these values
deck4$value[deck4$suit == "hearts"] <- 1
deck4$value[deck4$suit == "hearts"]
deck4[deck4$face == "queen"]
deck4[deck4$face == "queen", ]
deck4[deck4$suit == "spades", ]
# will use Boolean Operators to find queen of spades
# "and" (&), "or" (|), is exactly one (xor), false (!), are any true (any), are all true (all)
# “Is x greater than two and is x less than nine?”
x > 2 & x < 9
# will use Boolean Operators to find queen of spades
# "and" (&), "or" (|), is exactly one (xor), false (!), are any true (any), are all true (all)
# “Is x greater than two and is x less than nine?” x > 2 & x < 9
a <- c(1, 2, 3)
b <- c(1, 2, 3)
c <- c(1, 2, 4)
a == b
b == c
a == b & b == c
deck4$face == "queen" & deck4$suit == "spades"
queenofspades <-  deck4$face == "queen" & deck4$suit == "spades"
deck4[queenofspades, ]
deck4$value[queenofspades]
# now we can update the queen of spades value from 0 to 13
deck4$value[queenofspades] <- 13
deck4[queenofspades, ]
# Exercise
w <- c(-1, 0, 1)
x <- c(5, 15)
y <- "February"
z <- c("Monday", "Tuesday", "Friday")
w > 0
x > 10 & x < 20
y = "Feburary"
y <- "February"
y == "Feburary"
y == "Febuary"
y == "February"
all(z %in% c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"))
# Blackjack
deck5 <- deck
head(deck5, 13)
facecard <- deck5$face %in% c("king", "queen", "jack")
View(deck5)
deck5[facecard, ]
facecard
deck5$value[facecard] <- 10
head(deck5, 13)
# missing information
1 + NA
NA == 1
c(NA, 1:50)
mean(c(NA, 1:50))
mean(c(na, 1:50), na.rm = TRUE)
mean(c(NA, 1:50), na.rm = TRUE)
NA == NA
is.na(NA)
vec <- c(1, 2, 3, NA)
is.na(vec)
deck5$value[deck5$face == "ace"] <- NA
head(deck5, 13)
# single brackets keeps the list structure
lst[1]
lst <- list(numbers = c(1, 2), logical = TRUE, strings = c("a", "b", "c"))
lst
# single brackets keeps the list structure
lst[1]
lst["numbers"]
lst[["numbers"]]
# double brackets for position if name is not specifed returns values
lst[[1]]
